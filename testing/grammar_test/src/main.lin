use ::a_module::a_foo;
use ::a_module::a_bar;
use ::b_module;

fn xyz(arg: A<int, X>, list_list: List<List<List<List<bool>>>>) -> Vec<Option<bool>> {

}

fn my_cool_fn(arg1: i32, arg2: i32) -> i32{
    return arg2 - arg1
}

fn main() {
    println("Hello, world!", "Goodbye, world!");
    let a = 0; // a comment
    let b: (bool, (bool, bool)) = "";
    let mut c = 0xFF;
    let mut d: Option<i32> = 0;
    c <<= x>>1;
    f = c;
    x = has_foo();
    y = 1 + 2;
    path::to::println(0q32i8);
    a_foo();
    a_bar();
    b_module::b_foo();
    b_module::b_bar();
    b_module::b_foo();
}
